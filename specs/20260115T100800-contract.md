# Contract Architecture Specification

> **Version**: 1.0 (V1 Scope)  
> **Last Updated**: 2026-01-16  
> **Status**: Ready for Implementation

## Overview

Contracts define the data shape for Epicenter workspaces. A contract is a static TypeScript/JSON object that describes tables and key-value stores. Data is stored in Y.Doc for real-time collaboration.

**V1 Constraints:**

- Cell values are JSON-serializable: strings, numbers, booleans, null, and `string[]` for tags
- Official app schemas are bundled; user-created schemas are V2
- Persistence: IndexedDB (browser) only; filesystem is V2 (Tauri)
- Y.Doc-only storage (SQLite materialization is V2)

---

## Quick Example

```typescript
import { defineContract, createYjsClient } from '@epicenter/core';

// Define a contract (static, compile-time)
const whisperingContract = defineContract({
	name: 'Whispering',
	version: '1.0.0',
	tables: {
		recordings: {
			id: { type: 'id' },
			title: { type: 'text' },
			transcript: { type: 'text', nullable: true },
			duration: { type: 'real' },
			createdAt: { type: 'date' },
		},
	},
	kv: {
		defaultModel: {
			type: 'select',
			options: ['whisper-1', 'whisper-large-v3'],
			default: 'whisper-1',
		},
		language: { type: 'text', default: 'en' },
	},
});

// Create a client (runtime)
const client = createYjsClient(whisperingContract, {
	workspaceId: 'ws_whispering',
	persistence: 'indexeddb',
});

// Use it
await client.whenSynced;
client.tables.recordings.upsert({
	id: generateId(),
	title: 'Meeting Notes',
	transcript: null,
	duration: 120.5,
	createdAt: new Date().toISOString(),
});
```

---

## Glossary

| Term            | Definition                                                      |
| --------------- | --------------------------------------------------------------- |
| **Contract**    | Static schema object defining tables and KV structure           |
| **schemaId**    | Identifier for a contract (e.g., `epicenter.whispering`)        |
| **workspaceId** | Instance identifier for data (e.g., `ws_whispering`)            |
| **epoch**       | Version number for Y.Doc migrations (0, 1, 2...)                |
| **tableId**     | Key for a table in the contract (camelCase, e.g., `recordings`) |
| **rowId**       | Primary key for a row (nanoid, e.g., `V1StGXR8_Z5jdHi6B`)       |
| **displayName** | Human-readable name stored in metadata (optional)               |

---

## 1. Contract Type Definition

```typescript
/**
 * A contract defines the schema for a workspace.
 * The contract object does NOT contain an `id` field.
 * Schema identity comes from registration/filename.
 */
type Contract<
	TTableSchemaMap extends TableSchemaMap = TableSchemaMap,
	TKvSchemaMap extends KvSchemaMap = KvSchemaMap,
> = {
	/** Human-readable display name */
	name: string;
	/** Schema version (semver) */
	version: string;
	/** Table schemas keyed by tableId (camelCase) */
	tables: TTableSchemaMap;
	/** KV schemas keyed by keyId (camelCase) */
	kv: TKvSchemaMap;
};

type TableSchemaMap = Record<string, FieldSchemaMap>;
type KvSchemaMap = Record<string, FieldSchema>;
type FieldSchemaMap = { id: FieldSchema } & Record<string, FieldSchema>;
```

### Field Schema

```typescript
type FieldSchema = {
	type: FieldType;
	nullable?: boolean; // Default: false. If true, field can be null.
	default?: unknown; // Default value applied at read time (not write time)
	options?: string[]; // REQUIRED for 'select'. Optional for 'tags' (constrains values).
};

type FieldType =
	| 'id' // String ID. Caller must provide (use generateId()).
	| 'text' // String
	| 'integer' // Integer number
	| 'real' // Floating point number
	| 'boolean' // Boolean
	| 'date' // ISO 8601 date string (e.g., "2026-01-16T12:00:00Z")
	| 'select' // Single choice from options (options REQUIRED)
	| 'tags'; // Array of strings (options optional constraint)
```

### Contract Validation Rules

A contract is **invalid** if:

- A table's `id` field is not `{ type: 'id' }` (every table must have `id: { type: 'id' }`)
- A `select` field is missing `options` or has empty `options`
- `options` contains duplicates
- `default` value doesn't match the field type
- A non-nullable KV key has no `default` (would be unreadable when unset)

### Type Inference

```typescript
/**
 * Helper type to check if a type is `never`.
 * Uses the fact that `never` is the only type where [never] extends [X] fails.
 */
type IsNever<T> = [T] extends [never] ? true : false;

/** Infer TypeScript type from FieldSchema */
type InferFieldType<T extends FieldSchema> = T['type'] extends
	| 'id'
	| 'text'
	| 'date'
	| 'select'
	? string
	: T['type'] extends 'integer' | 'real'
		? number
		: T['type'] extends 'boolean'
			? boolean
			: T['type'] extends 'tags'
				? string[]
				: never;

/**
 * Infer the STORED row type (fully materialized, defaults applied).
 * Used for return types from get/getAll/getAllValid.
 *
 * All read methods return only valid, normalized rows.
 * Invalid rows are excluded and accessible via getAllInvalid().
 */
type InferRow<T extends FieldSchemaMap> = {
	[K in keyof T]: T[K]['nullable'] extends true
		? InferFieldType<T[K]> | null
		: InferFieldType<T[K]>;
};

/**
 * Infer the INPUT row type for upsert.
 * - 'id' is always required
 * - Fields with defaults can be omitted
 * - Nullable fields can be omitted (stored as missing, read as null)
 */
type InferRowInput<T extends FieldSchemaMap> = {
	// Required: 'id' + non-nullable fields without defaults
	[K in keyof T as K extends 'id'
		? K
		: T[K] extends { default: unknown }
			? never
			: T[K]['nullable'] extends true
				? never
				: K]: InferFieldType<T[K]>;
} & {
	// Optional: fields with defaults OR nullable fields
	[K in keyof T as K extends 'id'
		? never
		: T[K] extends { default: unknown }
			? K
			: T[K]['nullable'] extends true
				? K
				: never]?: T[K]['nullable'] extends true
		? InferFieldType<T[K]> | null
		: InferFieldType<T[K]>;
};

/**
 * Raw row as stored in Y.Doc (before validation/defaults).
 * Used for getAllInvalid to expose actual stored data.
 */
type RawRow = Record<string, CellValue | undefined>;
```

---

## 2. defineContract Function

```typescript
/**
 * Type-preserving identity function for contracts.
 * No runtime transformation — returns the same object.
 */
function defineContract<
	TTableSchemaMap extends TableSchemaMap,
	TKvSchemaMap extends KvSchemaMap,
>(
	contract: Contract<TTableSchemaMap, TKvSchemaMap>,
): Contract<TTableSchemaMap, TKvSchemaMap> {
	return contract;
}
```

**Example:**

```typescript
const tasksContract = defineContract({
	name: 'Tasks',
	version: '1.0.0',
	tables: {
		tasks: {
			id: { type: 'id' },
			title: { type: 'text' },
			status: { type: 'select', options: ['todo', 'doing', 'done'] },
			dueDate: { type: 'date', nullable: true },
		},
		projects: {
			id: { type: 'id' },
			name: { type: 'text' },
			color: { type: 'text', default: '#3B82F6' },
		},
	},
	kv: {
		defaultView: {
			type: 'select',
			options: ['list', 'board'],
			default: 'list',
		},
	},
});
```

---

## 3. Y.Doc Structure

The Y.Doc stores only data. Schema is external (passed to `createYjsClient`).

```
Y.Doc (documentName: "{workspaceId}-{epoch}")
├── 'tables' (Y.Map)
│   └── '{tableId}' (Y.Map)
│       └── '{rowId}' (Y.Map)
│           └── '{fieldId}' → CellValue
├── 'kv' (Y.Map)
│   └── '{keyId}' → CellValue
└── 'metadata' (Y.Map, RESERVED for V2)
    └── ... display names, icons, etc. (not implemented in V1)
```

> **V1 Note:** The `metadata` map structure is reserved but not implemented.
> V1 uses contract `name` for display. Custom display names are V2.

### Cell Values

All values are JSON primitives:

```typescript
type CellValue = string | number | boolean | null | string[]; // for 'tags' type only
```

### Row Identity

The **rowId** (Y.Map key) and the row's **`id` field** MUST be identical.

```typescript
// The rowId key equals the id field value
tablesMap.get('recordings').set(row.id, rowMap);
rowMap.set('id', row.id); // Stored redundantly for query convenience
```

**Invariant enforcement:**

- `upsert()` uses `row.id` as both the Y.Map key and stored value
- `getAllInvalid()` returns `{ id: rowId, raw, errors }` where `id` is the Y.Map key
- If stored `id` field differs from rowId, treat as validation error: "id field mismatch"

---

## 4. createYjsClient API

```typescript
type YjsClientOptions = {
	/** Workspace ID for data location and sync routing */
	workspaceId: string;
	/** Epoch number for versioning. Default: 0 */
	epoch?: number;
	/** Y-Sweet sync URL. Optional. */
	syncUrl?: string;
	/**
	 * Persistence strategy. Default: 'none'
	 * - 'indexeddb': Browser persistence (V1 supported)
	 * - 'none': In-memory only (V1 supported)
	 *
	 * Note: Filesystem persistence via Tauri is V2.
	 */
	persistence?: 'indexeddb' | 'none';
	/** Existing Y.Doc (for testing/migration) */
	ydoc?: Y.Doc;
};

type YjsClient<TContract extends Contract> = {
	readonly contract: TContract;
	readonly workspaceId: string;
	readonly epoch: number;
	readonly tables: YjsTables<TContract['tables']>;
	/**
	 * KV helpers. Empty object `{}` if contract has empty KV schema.
	 *
	 * Since KV is always required in Contract (never undefined), we can
	 * directly use TContract['kv'] without NonNullable wrappers or IsNever checks.
	 */
	readonly kv: YjsKv<TContract['kv']>;
	readonly ydoc: Y.Doc;

	/**
	 * Promise that resolves when the client is ready for use.
	 *
	 * Resolution order:
	 * 1. If `options.ydoc` provided: use it directly, resolve immediately
	 * 2. Else if `persistence` is 'indexeddb': load from IndexedDB, then resolve
	 * 3. If `syncUrl` provided: attempt connection with 5s timeout
	 *    - Connected within 5s: resolve after initial sync
	 *    - Timeout or error: resolve anyway (sync continues in background)
	 *
	 * Never rejects. Always resolves within 5s of local state being usable.
	 * Check `syncStatus` to know if sync is actually connected.
	 */
	readonly whenSynced: Promise<void>;

	/**
	 * Current sync status (for UI indicators).
	 * - 'disconnected': No syncUrl, or connection lost
	 * - 'connecting': Attempting to connect
	 * - 'synced': Connected and in sync
	 *
	 * Transitions: disconnected → connecting → synced
	 * On connection loss: synced → disconnected (auto-reconnect attempts)
	 */
	readonly syncStatus: 'disconnected' | 'connecting' | 'synced';

	/** Clean up: disconnect sync, close persistence */
	destroy(): Promise<void>;
};

function createYjsClient<TContract extends Contract>(
	contract: TContract,
	options: YjsClientOptions,
): YjsClient<TContract>;
```

---

## 5. Table Operations

```typescript
type YjsTables<T extends TableSchemaMap> = {
	[K in keyof T]: YjsTable<T[K]>;
};

type YjsTable<TFieldSchema extends FieldSchemaMap> = {
	/**
	 * Get row by ID. Returns undefined if not found or if row is invalid.
	 *
	 * Normalization:
	 * - Missing fields with defaults → filled with default
	 * - Missing nullable fields → filled with null
	 * - Wrong types → coerced if possible (e.g., "123" → 123 for integer)
	 *
	 * If row cannot be normalized to valid InferRow (e.g., missing required field,
	 * uncoercible type), returns undefined. Use getAllInvalid() to access such rows.
	 */
	get(id: string): InferRow<TFieldSchema> | undefined;

	/**
	 * Get all VALID rows with normalization applied. Sorted by ID.
	 * Equivalent to getAllValid(). Excludes rows that fail validation.
	 *
	 * Type guarantee: Always returns valid InferRow[] that matches the schema.
	 */
	getAll(): InferRow<TFieldSchema>[];

	/**
	 * Get only rows that pass schema validation (defaults applied). Sorted by ID.
	 * Excludes: wrong types, missing required fields, id mismatch, etc.
	 */
	getAllValid(): InferRow<TFieldSchema>[];

	/**
	 * Get rows that fail validation. Sorted by ID.
	 * Returns RAW data (no defaults) so you can see actual stored values.
	 * The `id` is the Y.Map key (rowId), which is authoritative.
	 */
	getAllInvalid(): Array<{
		id: string;
		raw: RawRow;
		errors: ValidationError[];
	}>;

	/**
	 * Insert or update a row (FULL REPLACE).
	 * - ID field is REQUIRED (caller generates with generateId())
	 * - Fields with defaults can be omitted (won't be stored)
	 * - This REPLACES the entire row; fields not provided are removed
	 * - Defaults are NOT stored; they're applied at read time
	 *
	 * Write-time validation: Values are written as-is (no coercion).
	 * Invalid values will cause the row to appear in getAllInvalid().
	 * TypeScript types prevent most invalid writes at compile time.
	 */
	upsert(row: InferRowInput<TFieldSchema>): void;

	/**
	 * Update specific fields of existing row (MERGE/PATCH).
	 * - Only provided fields are updated; others remain unchanged
	 * - No-op if row doesn't exist (idempotent)
	 * - Pass undefined for a field to unset it (removes from storage, will read as default/null)
	 */
	update(id: string, fields: UpdateFields<TFieldSchema>): void;

	/**
	 * Delete row by ID.
	 * No-op if row doesn't exist (idempotent).
	 */
	delete(id: string): void;

	/**
	 * Subscribe to changes.
	 * - Callback fires immediately with current rows (via getAll)
	 * - Rows are sorted by ID for deterministic ordering
	 * - Returns unsubscribe function
	 */
	subscribe(callback: (rows: InferRow<TFieldSchema>[]) => void): () => void;
};

/**
 * Update fields type: allows setting to value, null (if nullable), or undefined (to unset).
 */
type UpdateFields<T extends FieldSchemaMap> = {
	[K in Exclude<keyof T, 'id'>]?:
		| InferFieldType<T[K]>
		| (T[K]['nullable'] extends true ? null : never)
		| undefined; // undefined = unset/remove from storage
};

type ValidationError = {
	field: string;
	message: string;
	expected: string;
	received: string;
};
```

### Validation Rules

A row is **invalid** if any of these conditions are true:

| Condition                                         | Error Message                            |
| ------------------------------------------------- | ---------------------------------------- |
| Missing required field (non-nullable, no default) | "Required field '{field}' is missing"    |
| Wrong type                                        | "Expected {expected}, got {received}"    |
| `select` value not in options                     | "Value '{value}' not in allowed options" |
| `tags` value not in options (if options defined)  | "Tag '{value}' not in allowed options"   |
| `date` not valid ISO 8601                         | "Invalid date format"                    |
| rowId (Y.Map key) differs from stored `id` field  | "id field mismatch"                      |

**Notes:**

- Extra fields in stored data (orphaned after schema change) are ignored, not errors.
- Missing nullable fields (not stored) are valid; read as `null`.
- Missing non-nullable fields with defaults are valid; read returns the default.

### Date Validation

A `date` field value is valid if:

- It can be parsed by `new Date(value)` without returning `Invalid Date`
- It matches ISO 8601 format (recommended: `YYYY-MM-DDTHH:mm:ss.sssZ`)

Accept both full timestamps (`2026-01-16T12:00:00Z`) and date-only (`2026-01-16`).

### Default Validation

When validating contract defaults:

- `select` default must be one of `options`
- `tags` default must be `string[]`; if `options` defined, each tag must be in `options`
- `integer` default must be a whole number (`Number.isInteger(value)`)
- `date` default must pass date validation rules above

### Read-Time Coercion Rules

When reading rows, the following coercions are applied (best-effort normalization):

| Field Type | Stored Value                 | Coerced To                      |
| ---------- | ---------------------------- | ------------------------------- |
| `text`     | number/boolean               | `String(value)`                 |
| `integer`  | string that parses as int    | `parseInt(value, 10)`           |
| `integer`  | float                        | `Math.trunc(value)`             |
| `real`     | string that parses as number | `parseFloat(value)`             |
| `boolean`  | `"true"/"false"`             | `true/false`                    |
| `boolean`  | `0/1`                        | `false/true`                    |
| `date`     | number (epoch ms)            | `new Date(value).toISOString()` |
| `select`   | any non-matching value       | **not coerced** (invalid)       |
| `tags`     | any non-array                | **not coerced** (invalid)       |

If coercion fails or isn't applicable, the row is marked invalid and excluded from `get()`/`getAll()`.

### Write-Time Behavior

`upsert()` and `update()` write values as-is with NO coercion:

- TypeScript types prevent most invalid writes at compile time
- At runtime, if you bypass types (e.g., via `as any`), invalid values are stored
- Invalid rows will appear in `getAllInvalid()` but not in `get()`/`getAll()`
- This is intentional: don't silently coerce user data on write

---

## 6. KV Operations

```typescript
type YjsKv<T extends KvSchemaMap> = keyof T extends never
	? Record<string, never> // Empty KV schema `{}` → no methods
	: {
			/**
			 * Get value.
			 * - If key is unset: return default (if exists) or null
			 * - If key is set: return the stored value
			 */
			get<K extends keyof T>(key: K): InferKvValue<T[K]>;

			/**
			 * Set value. Persists the value in Y.Doc.
			 * - For nullable fields: can set to null (stores explicit null)
			 * - For non-nullable fields: cannot set to null (throws at runtime)
			 * - To "unset" and restore default behavior: use delete(key)
			 */
			set<K extends keyof T>(key: K, value: InferKvValue<T[K]>): void;

			/**
			 * Delete/unset a key. Next get() returns default or null.
			 */
			delete<K extends keyof T>(key: K): void;

			/**
			 * Subscribe to changes.
			 * - Fires immediately with current values
			 * - Then fires on every change
			 */
			subscribe(
				callback: (kv: { [K in keyof T]: InferKvValue<T[K]> }) => void,
			): () => void;
		};

/** Infer KV value type, respecting nullable */
type InferKvValue<T extends FieldSchema> = T['nullable'] extends true
	? InferFieldType<T> | null
	: InferFieldType<T>; // Non-nullable: value or default, never null
```

### KV Semantics

| Stored State  | Has Default | Nullable | `get()` Returns                                               |
| ------------- | ----------- | -------- | ------------------------------------------------------------- |
| Unset         | Yes         | -        | default value                                                 |
| Unset         | No          | Yes      | `null`                                                        |
| Unset         | No          | No       | **Error** (contract invalid: non-nullable KV without default) |
| Set to value  | -           | -        | the value                                                     |
| Set to `null` | -           | Yes      | `null`                                                        |
| Set to `null` | -           | No       | Error (cannot set non-nullable to null)                       |

---

## 7. Schema Hosting

### Official Apps (Bundled)

```typescript
// In Epicenter app bundle
const bundledSchemas: Record<string, Contract> = {
	'epicenter.whispering': whisperingContract,
	'epicenter.tasks': tasksContract,
};
```

### User-Created Schemas (V2)

User-created schemas (e.g., AI-generated) are deferred to V2.

V1 supports only bundled official app schemas.

### Schema Resolution (V1)

```typescript
function resolveSchema(schemaId: string): Contract | null {
	// V1: Only bundled schemas supported
	if (schemaId in bundledSchemas) {
		return bundledSchemas[schemaId];
	}
	return null;
}
```

**V2 will add:** Filesystem-based user schemas (see path convention note below)

---

## 8. File Paths

**V1 (Browser/IndexedDB):**

```
IndexedDB database: "epicenter"
├── store: "ydocs"
│   └── key: "{workspaceId}-{epoch}" → Y.Doc binary
└── store: "registry"
    └── key: "workspaces" → WorkspaceRegistry JSON
```

**V2 (Filesystem/Tauri):**

```
<project>/.epicenter/
├── providers/
│   ├── persistence/                   # Y.Doc persistence
│   ├── sqlite/                        # SQLite materialization
│   └── markdown/                      # Markdown export
├── schemas/
│   └── {schemaId}.json               # User-created schemas
└── registry.json                      # Local workspace registry
```

> **Path convention update (2026-02):** This spec originally proposed `~/.epicenter/` for workspace data. The convention has since been refined: workspace data lives at `<project>/.epicenter/` (project-local), while `~/.epicenter/server/` is reserved for global server config (API keys, master encryption key, server settings). See `specs/20260222T195800-server-side-api-key-management.md` and `docs/articles/home-dotfiles-beat-xdg-for-developer-tools.md` for details.

**Note:** V1 uses IndexedDB only. Filesystem paths are for V2 (Tauri).

---

## 9. Workspace Registry

Tracks which workspaces exist locally:

```typescript
type WorkspaceRegistry = {
	workspaces: Record<string, WorkspaceEntry>;
};

type WorkspaceEntry = {
	schemaId: string; // e.g., "epicenter.whispering"
	epoch: number; // Current epoch (default: 0)
	syncUrl?: string; // Y-Sweet URL (optional)
	lastOpened?: string; // ISO timestamp
	// Note: displayName is V2 (stored in Y.Doc metadata)
};
```

**V1 Storage:** IndexedDB store `"registry"`, key `"workspaces"`

**Data format (JSON-serializable):**

```json
{
	"ws_whispering": {
		"schemaId": "epicenter.whispering",
		"epoch": 0
	}
}
```

---

## 10. User Workflows

### Add Official App Workspace

```
1. User opens Epicenter
2. Clicks "Add Workspace"
3. Selects "Whispering" from bundled apps list
4. System:
   a. schema = bundledSchemas['epicenter.whispering']
   b. workspaceId = 'ws_whispering' (or generate if exists)
   c. Add to registry: { schemaId: 'epicenter.whispering', epoch: 0 }
   d. createYjsClient(schema, { workspaceId, persistence: 'indexeddb' })
   e. Load existing Y.Doc or create new one
5. Workspace appears in sidebar
```

### Create User Schema with AI (V2)

> **Note:** This workflow is V2. V1 supports only bundled official apps.

```
1. User clicks "Add Workspace" → "Generate with AI"
2. Enters prompt: "Sales CRM with leads and companies"
3. AI generates contract JSON
4. System:
   a. schemaId = 'user.{userId}.sales-crm'
   b. Save to ~/.epicenter/schemas/{schemaId}.json
   c. workspaceId = 'ws_sales-crm'
   d. Add to registry
   e. Create client
5. Empty tables ready for data
```

### Shared Data Between Apps

Whispering app and Epicenter editor can share the same data:

```typescript
// Both apps use same workspaceId
const client = createYjsClient(whisperingContract, {
	workspaceId: 'ws_whispering',
	persistence: 'indexeddb',
});
```

When Whispering writes a recording, Epicenter editor sees it immediately (same Y.Doc file).

---

## 11. Error States

| Scenario                         | UI Behavior                            |
| -------------------------------- | -------------------------------------- |
| Schema not found                 | Show error: "Unknown app: {schemaId}"  |
| Workspace already exists         | Offer: "Open existing" or "Create new" |
| Sync connection failed           | Show banner: "Offline mode"            |
| Invalid rows after schema change | Highlight rows; show validation errors |

---

## 12. CLI Generation

Generate CLI commands from a contract:

```typescript
function generateCli(contract: Contract): CliCommands {
	// For each table: list, get, add, update, delete
	// For KV: get, set
}
```

**Example output for Whispering:**

```bash
epicenter recordings list
epicenter recordings get <id>
epicenter recordings add --title "Meeting" --duration 120
epicenter recordings update <id> --title "Updated Title"
epicenter recordings delete <id>

epicenter kv get defaultModel
epicenter kv set defaultModel whisper-1
```

---

## 13. SKILL.md Generation

Generate AI skill documentation from a contract:

```typescript
function generateSkillMd(contract: Contract): string {
	// Markdown documentation of tables, fields, and CLI commands
}
```

---

## V1 Implementation Checklist

### Phase 1: Core Contract

- [ ] `Contract` type definition
- [ ] `FieldSchema` type definition
- [ ] `InferRow` / `InferFieldType` type utilities
- [ ] `defineContract()` function
- [ ] `resolveSchema()` function

### Phase 2: Y.js Client

- [ ] `YjsClientOptions` type
- [ ] `YjsClient` type
- [ ] `createYjsClient()` function
- [ ] Table operations (get, getAll, upsert, update, delete)
- [ ] KV operations (get, set)
- [ ] Validation helpers (getAllValid, getAllInvalid)
- [ ] `generateId()` function (nanoid)
- [ ] IndexedDB persistence

### Phase 3: Registry & UI

- [ ] Workspace registry (IndexedDB store "registry")
- [ ] "Add Workspace" UI flow
- [ ] Bundled schemas registration

### Phase 4: CLI (Next Sprint)

- [ ] `generateCli()` function
- [ ] `generateSkillMd()` function

---

## Deferred to V2

1. **SQLite materialization** — Query layer for complex queries
2. **Multi-device workspace discovery** — Registry sync across devices
3. **Schema version conflict resolution** — Auto-merge strategies
4. **Rich text cells** — Y.Text for collaborative editing within cells
5. **Hybrid sync** — Bidirectional SQLite ↔ Y.Doc reconciliation
6. **Dynamic schema editor UI** — Visual schema editing in Epicenter

---

## V1 Decisions (Locked)

These decisions are locked for V1 implementation:

| Decision                            | Choice                    | Rationale                                 |
| ----------------------------------- | ------------------------- | ----------------------------------------- |
| **Sync URL storage**                | Workspace registry        | Per-workspace config in IndexedDB         |
| **Contract `version` field**        | Required                  | Forces explicit versioning for migrations |
| **Multi-device discovery**          | Manual re-add             | V1 is local-only; registry sync is V2     |
| **Persistence options**             | `indexeddb` or `none`     | Filesystem (Tauri) is V2                  |
| **Metadata (display names, icons)** | Reserved, not implemented | V1 uses contract `name` only              |
| **Registry storage**                | IndexedDB                 | V1 is browser-only; filesystem is V2      |

## Open Questions (V2 Considerations)

These are deferred to V2 planning:

### OQ1: Multi-Device Discovery

How will users discover workspaces on new devices?

- A) Registry itself is a synced Y.Doc (recommended)
- B) Scan Y-Sweet server for user's docs
- C) Cloud account with workspace list

### OQ2: Filesystem Persistence

How should Tauri apps persist Y.Doc to filesystem?

- A) Direct file write to `~/.epicenter/data/`
- B) Tauri fs plugin with platform-specific paths
- C) SQLite-backed persistence (y-indexeddb pattern)

---

## Appendix: Design History

<details>
<summary>Click to expand iteration history</summary>

This spec evolved through several iterations:

1. **Initial design**: Human-readable table names with slugification
2. **Revision 1**: Schema inside Y.Doc with `meta` map
3. **Revision 2**: Schema external to Y.Doc (current approach)
4. **Revision 3**: Removed `ytext` field type; JSON primitives only
5. **Revision 4**: Simplified to V1 scope; SQLite/hybrid deferred

Key decisions made during iteration:

- **No slugification**: Table keys are used as-is (camelCase)
- **No `meta` in Y.Doc**: Schema passed at client creation time
- **JSON cells only**: No Y.Text/Y.Array in row data for V1
- **Local-only schemas**: No CDN/network fetch for V1

</details>
