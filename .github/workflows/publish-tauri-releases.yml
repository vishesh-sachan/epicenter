name: Publish Tauri Releases

on:
  push:
    tags:
      - 'v*'  # Trigger on version tags like v7.0.0
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to build and release (e.g., v7.9.0)'
        required: true
        type: string

jobs:
  # Job to clean up existing release assets before building
  cleanup-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Delete existing release assets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ github.event.inputs.tag || github.ref_name }}"
          echo "Cleaning up assets for release: $TAG"
          
          # Get release ID
          RELEASE_ID=$(gh api repos/${{ github.repository }}/releases/tags/$TAG --jq '.id' 2>/dev/null || echo "")
          
          if [ -n "$RELEASE_ID" ]; then
            echo "Found release ID: $RELEASE_ID"
            
            # Get all assets and delete them
            ASSETS=$(gh api repos/${{ github.repository }}/releases/$RELEASE_ID/assets --jq '.[].id' 2>/dev/null || echo "")
            
            for ASSET_ID in $ASSETS; do
              echo "Deleting asset: $ASSET_ID"
              gh api -X DELETE repos/${{ github.repository }}/releases/assets/$ASSET_ID || true
            done
            
            echo "Cleanup complete"
          else
            echo "No existing release found for $TAG, skipping cleanup"
          fi

  publish-tauri:
    needs: cleanup-release
    # Required permissions to create releases and upload assets
    permissions:
      contents: write

    # Build strategy: create separate jobs for each platform
    strategy:
      fail-fast: false  # Continue building other platforms even if one fails
      matrix:
        include:
          # macOS Apple Silicon (M1, M2, M3, etc.)
          - platform: 'macos-latest'
            args: '--target aarch64-apple-darwin'

          # macOS Intel-based
          - platform: 'macos-latest'
            args: '--target x86_64-apple-darwin'

          # Linux (Ubuntu)
          - platform: 'ubuntu-22.04'
            args: ''  # No specific target needed for Linux

          # Windows
          - platform: 'windows-latest'
            args: ''  # No specific target needed for Windows

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.tag || github.ref }}

      # macOS specific: Install create-dmg for DMG bundling
      - name: Install create-dmg (macOS only)
        if: matrix.platform == 'macos-latest'
        run: brew install create-dmg

      # Ubuntu/Linux specific: Install system dependencies required by Tauri
      - name: install dependencies (ubuntu only)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          # Dependencies explanation:
          # - libwebkit2gtk-4.1-dev: WebKit engine for Tauri v2 (4.0 was for v1)
          # - libappindicator3-dev: System tray support
          # - librsvg2-dev: SVG rendering
          # - patchelf: Required for AppImage packaging
          # - libxdo-dev: Keyboard/mouse automation
          # - libasound2-dev: Audio support
          # - libopenblas-dev: GPU acceleration support
          # - libx11-dev: X11 development files for window system interaction
          # - libxtst-dev: X11 testing extensions for input simulation
          # - libxrandr-dev: X11 RandR extension for display configuration
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf libxdo-dev libasound2-dev libopenblas-dev libx11-dev libxtst-dev libxrandr-dev

      # Setup Bun package manager
      - name: setup bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: "package.json"

      # Setup Node.js for compatibility
      - name: setup node
        uses: actions/setup-node@v4
        with:
          node-version: lts/*

      # Install Rust toolchain required for building Tauri
      - name: install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          # For macOS: specify both Intel and ARM targets
          # For other platforms: empty string (uses default target)
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      # Cache Rust dependencies for faster builds
      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          # Point to the Rust project directory
          workspaces: './apps/whispering/src-tauri -> target'

      # Install all JavaScript dependencies
      - name: install frontend dependencies
        run: bun install

      # Build the frontend (SvelteKit app) before Tauri packaging
      - name: Build frontend
        run: bun --filter @epicenter/whispering build  # Targets the specific workspace package

      # Read and process release notes from the release-notes directory
      - name: Process release notes
        id: release_notes
        shell: bash
        run: |
          TAG="${{ github.event.inputs.tag || github.ref_name }}"
          # Look for release notes file matching the tag name (e.g., v7.0.0 -> docs/release-notes/v7.0.0.md)
          RELEASE_FILE="docs/release-notes/$TAG.md"

          if [ -f "$RELEASE_FILE" ]; then
            echo "Found release notes file: $RELEASE_FILE"

            # Get full content for GitHub release page
            RELEASE_NOTES=$(cat "$RELEASE_FILE")
          else
            echo "No release notes file found at $RELEASE_FILE, using fallback"
            # Fallback message if no release file exists
            RELEASE_NOTES="Whispering $TAG is now available. Check GitHub for the full changelog."
          fi

          # Save output for use in later steps
          # Using EOF delimiter to handle multi-line content
          echo "RELEASE_NOTES<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Main Tauri build and release action
      - uses: tauri-apps/tauri-action@v0
        env:
          # Set CI environment variable to help with DMG bundling
          CI: true

          # Required: GitHub token for creating releases and uploading assets
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

          # Aptabase analytics key
          APTABASE_KEY: ${{ secrets.APTABASE_KEY }}

          # Tauri code signing (optional but recommended)
          # These enable automatic updates without security warnings
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}

          # macOS code signing and notarization (required for distribution)
          # Without these, macOS users will see security warnings
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}  # App-specific password
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

        with:
          # Path to the Tauri project (where tauri.conf.json is located)
          projectPath: 'apps/whispering'

          # Use the actual git tag as the release tag (e.g., v7.0.0)
          tagName: ${{ github.event.inputs.tag || github.ref_name }}

          # Release title shown on GitHub
          releaseName: 'Whispering ${{ github.event.inputs.tag || github.ref_name }}'

          # Release description from our processed release notes
          # Full release notes for GitHub release page
          releaseBody: ${{ steps.release_notes.outputs.RELEASE_NOTES }}

          # Create as draft so you can review before publishing
          releaseDraft: true

          # Set to false for beta/RC releases
          prerelease: false

          # Platform-specific build arguments (e.g., --target for macOS)
          args: ${{ matrix.args }}

      # Install FUSE for AppImage processing
      - name: Install FUSE for AppImage processing
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y fuse libfuse2

      # Remove libwayland-client.so from AppImage for better compatibility
      # This fixes EGL_BAD_PARAMETER errors on Wayland systems (Issues #114, #121)
      - name: Remove libwayland-client.so from AppImage
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          # Find the AppImage file
          APPIMAGE_PATH=$(find apps/whispering/src-tauri/target/release/bundle/appimage -name "*.AppImage" | head -1)

          if [ -n "$APPIMAGE_PATH" ]; then
            echo "Processing AppImage: $APPIMAGE_PATH"

            # Make AppImage executable
            chmod +x "$APPIMAGE_PATH"

            # Extract using the AppImage itself
            cd "$(dirname "$APPIMAGE_PATH")"
            APPIMAGE_NAME=$(basename "$APPIMAGE_PATH")
            "./$APPIMAGE_NAME" --appimage-extract

            # Remove libwayland-client.so files
            echo "Removing libwayland-client.so files..."
            find squashfs-root -name "libwayland-client.so*" -type f -delete

            # List what was removed for verification
            echo "Files remaining in lib directories:"
            find squashfs-root -name "lib*" -type d | head -5 | while read dir; do
              echo "Contents of $dir:"
              ls "$dir" | grep -E "(wayland|fuse)" || echo "  No wayland/fuse libraries found"
            done

            # Get appimagetool
            wget -q https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
            chmod +x appimagetool-x86_64.AppImage

            # Repackage AppImage with no-appstream to avoid warnings
            ARCH=x86_64 ./appimagetool-x86_64.AppImage --no-appstream squashfs-root "$APPIMAGE_NAME"

            # Clean up
            rm -rf squashfs-root appimagetool-x86_64.AppImage

            echo "libwayland-client.so removed from AppImage successfully"
          else
            echo "No AppImage found to process"
          fi
